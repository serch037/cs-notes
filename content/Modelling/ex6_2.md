Title: First (Sixth Chapter) Exercise
Date: 2015-08-13 
Tags: Fifth-Semester 
Summary: This program simulates an object steering randomly.

## Experience 
By basing the code on the example (6.1) provided by the author, the modification was relatively simple, as we only required to vary the speed according to separate rules in the environment, in this case, its x coordinate. The program also draws these regions and a predicition on the object's future position based on its current velocity. 

## Code

### Main class
:::java 
        // BASED ON The Nature of Code
        // ORIGINALY BY Daniel Shiffman
        // http://natureofcode.com
        // ADAPTED BY SERGIO UGALDE MARCANO 

        // Two "vehicles" follow the mouse position

        // Implements Craig Reynold's autonomous steering behaviors
        // One vehicle "seeks"
        // One vehicle "arrives"
        // See: http://www.red3d.com/cwr/

        Vehicle v;
        PVector follow;
        void setup() {
          size(1000, 1000);
          v = new Vehicle(width/2, height/2);
          predict();

          //pixelDensity(2);
        }

        void predict(){
            follow = PVector.add(v.velocity,v.location);
          follow.add(v.velocity.mult(100));
        }

        void draw() {
          background(255);
          predict();

          // Draw an ellipse at the mouse location
          fill(125);
          stroke(0);
          strokeWeight(2);
          //ellipse(follow.x, follow.y, 48, 48);
          v.display(follow.x, follow.y);
          fill(125,0,0,50);
          rect(0,0,width/3,height);
          fill(0,125,0,50);
          rect(width/3,0,2*width/3,height);
          fill(125,125,0,50);
          rect(2*width/3,0,width/3,height);

          // Call the appropriate steering behaviors for our agents
          v.seek(follow);
          v.update();
          v.checkEdges();
          fill(100);
          v.display(v.location.x, v.location.y);
        }

### Vehicle Class
:::java
        // BASED ON The Nature of Code
        // ORIGINALY BY Daniel Shiffman
        // http://natureofcode.com
        // ADAPTED BY SERGIO UGALDE MARCANO 

    // Seek_Arrive

    // The "Vehicle" class

    class Vehicle {
      
      PVector location;
      PVector velocity;
      PVector acceleration;
      float r;
      float maxforce;    // Maximum steering force
      float maxspeed;    // Maximum speed

      Vehicle(float x, float y) {
        acceleration = new PVector(0,0);
        velocity = new PVector(1,-2);
        location = new PVector(x,y);
        r = 6;
        maxspeed = 3;
        maxforce = 0.1;
      }

    void calculate(){
    if (location.x<=width/3){
      maxspeed = 1;
      maxforce = 0.01;
    } else if (location.x<=2*width/3){
      maxspeed = 3;
        maxforce = 0.1;
    }else {
         maxspeed = 5;
      maxforce = 1;
        }
      
    }
      // Method to update location
      void update() {
        calculate();
        // Update velocity
        velocity.add(acceleration);
        // Limit speed
        velocity.limit(maxspeed);
        location.add(velocity);
        // Reset accelerationelertion to 0 each cycle
        acceleration.mult(0);
      }

      void applyForce(PVector force) {
        // We could add mass here if we want A = F / M
        acceleration.add(force);
      }

      // A method that calculates a steering force towards a target
      // STEER = DESIRED MINUS VELOCITY
      void seek(PVector target) {
        PVector desired = PVector.sub(target,location);  // A vector pointing from the location to the target
        
        // Scale to maximum speed
        desired.setMag(maxspeed);

        // Steering = Desired minus velocity
        PVector steer = PVector.sub(desired,velocity);
        steer.limit(maxforce);  // Limit to maximum steering force
        
        applyForce(steer);
      }
      void checkEdges(){
        if (location.x>width)location.x=0;
        if (location.y>height)location.y=0;
        if (location.x<0)location.x=width;
        if (location.y<0)location.y=height;
      }
      void display(float x, float y) {
        // Draw a triangle rotated in the direction of velocity
        float theta = velocity.heading2D() + PI/2;
        stroke(0);
        strokeWeight(1);
        pushMatrix();
        translate(x,y);
        rotate(theta);
        beginShape();
        vertex(0, -r*2);
        vertex(-r, r*2);
        vertex(r, r*2);
        endShape(CLOSE);
        popMatrix();
        
        
      }
    }